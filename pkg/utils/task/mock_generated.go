// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/utils/task/task.go
//
// Generated by this command:
//
//	mockgen --source pkg/utils/task/task.go --destination pkg/utils/task/mock_generated.go --package=task
//

// Package task is a generated GoMock package.
package task

import (
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
	controller_runtime "sigs.k8s.io/controller-runtime"
)

// MockContext is a mock of Context interface.
type MockContext[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockContextMockRecorder[T]
}

// MockContextMockRecorder is the mock recorder for MockContext.
type MockContextMockRecorder[T any] struct {
	mock *MockContext[T]
}

// NewMockContext creates a new mock instance.
func NewMockContext[T any](ctrl *gomock.Controller) *MockContext[T] {
	mock := &MockContext[T]{ctrl: ctrl}
	mock.recorder = &MockContextMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContext[T]) EXPECT() *MockContextMockRecorder[T] {
	return m.recorder
}

// Deadline mocks base method.
func (m *MockContext[T]) Deadline() (time.Time, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deadline")
	ret0, _ := ret[0].(time.Time)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// Deadline indicates an expected call of Deadline.
func (mr *MockContextMockRecorder[T]) Deadline() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deadline", reflect.TypeOf((*MockContext[T])(nil).Deadline))
}

// Done mocks base method.
func (m *MockContext[T]) Done() <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Done")
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// Done indicates an expected call of Done.
func (mr *MockContextMockRecorder[T]) Done() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Done", reflect.TypeOf((*MockContext[T])(nil).Done))
}

// Err mocks base method.
func (m *MockContext[T]) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockContextMockRecorder[T]) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockContext[T])(nil).Err))
}

// Self mocks base method.
func (m *MockContext[T]) Self() *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Self")
	ret0, _ := ret[0].(*T)
	return ret0
}

// Self indicates an expected call of Self.
func (mr *MockContextMockRecorder[T]) Self() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Self", reflect.TypeOf((*MockContext[T])(nil).Self))
}

// Value mocks base method.
func (m *MockContext[T]) Value(key any) any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value", key)
	ret0, _ := ret[0].(any)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockContextMockRecorder[T]) Value(key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockContext[T])(nil).Value), key)
}

// MockResult is a mock of Result interface.
type MockResult struct {
	ctrl     *gomock.Controller
	recorder *MockResultMockRecorder
}

// MockResultMockRecorder is the mock recorder for MockResult.
type MockResultMockRecorder struct {
	mock *MockResult
}

// NewMockResult creates a new mock instance.
func NewMockResult(ctrl *gomock.Controller) *MockResult {
	mock := &MockResult{ctrl: ctrl}
	mock.recorder = &MockResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResult) EXPECT() *MockResultMockRecorder {
	return m.recorder
}

// IsFailed mocks base method.
func (m *MockResult) IsFailed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsFailed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsFailed indicates an expected call of IsFailed.
func (mr *MockResultMockRecorder) IsFailed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFailed", reflect.TypeOf((*MockResult)(nil).IsFailed))
}

// Message mocks base method.
func (m *MockResult) Message() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Message")
	ret0, _ := ret[0].(string)
	return ret0
}

// Message indicates an expected call of Message.
func (mr *MockResultMockRecorder) Message() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Message", reflect.TypeOf((*MockResult)(nil).Message))
}

// RequeueAfter mocks base method.
func (m *MockResult) RequeueAfter() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RequeueAfter")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// RequeueAfter indicates an expected call of RequeueAfter.
func (mr *MockResultMockRecorder) RequeueAfter() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RequeueAfter", reflect.TypeOf((*MockResult)(nil).RequeueAfter))
}

// ShouldContinue mocks base method.
func (m *MockResult) ShouldContinue() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShouldContinue")
	ret0, _ := ret[0].(bool)
	return ret0
}

// ShouldContinue indicates an expected call of ShouldContinue.
func (mr *MockResultMockRecorder) ShouldContinue() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShouldContinue", reflect.TypeOf((*MockResult)(nil).ShouldContinue))
}

// MockWithMessage is a mock of WithMessage interface.
type MockWithMessage struct {
	ctrl     *gomock.Controller
	recorder *MockWithMessageMockRecorder
}

// MockWithMessageMockRecorder is the mock recorder for MockWithMessage.
type MockWithMessageMockRecorder struct {
	mock *MockWithMessage
}

// NewMockWithMessage creates a new mock instance.
func NewMockWithMessage(ctrl *gomock.Controller) *MockWithMessage {
	mock := &MockWithMessage{ctrl: ctrl}
	mock.recorder = &MockWithMessageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWithMessage) EXPECT() *MockWithMessageMockRecorder {
	return m.recorder
}

// With mocks base method.
func (m *MockWithMessage) With(format string, args ...any) Result {
	m.ctrl.T.Helper()
	varargs := []any{format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "With", varargs...)
	ret0, _ := ret[0].(Result)
	return ret0
}

// With indicates an expected call of With.
func (mr *MockWithMessageMockRecorder) With(format any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{format}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "With", reflect.TypeOf((*MockWithMessage)(nil).With), varargs...)
}

// MockBreakableResult is a mock of BreakableResult interface.
type MockBreakableResult struct {
	ctrl     *gomock.Controller
	recorder *MockBreakableResultMockRecorder
}

// MockBreakableResultMockRecorder is the mock recorder for MockBreakableResult.
type MockBreakableResultMockRecorder struct {
	mock *MockBreakableResult
}

// NewMockBreakableResult creates a new mock instance.
func NewMockBreakableResult(ctrl *gomock.Controller) *MockBreakableResult {
	mock := &MockBreakableResult{ctrl: ctrl}
	mock.recorder = &MockBreakableResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBreakableResult) EXPECT() *MockBreakableResultMockRecorder {
	return m.recorder
}

// Break mocks base method.
func (m *MockBreakableResult) Break() WithMessage {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Break")
	ret0, _ := ret[0].(WithMessage)
	return ret0
}

// Break indicates an expected call of Break.
func (mr *MockBreakableResultMockRecorder) Break() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Break", reflect.TypeOf((*MockBreakableResult)(nil).Break))
}

// With mocks base method.
func (m *MockBreakableResult) With(format string, args ...any) Result {
	m.ctrl.T.Helper()
	varargs := []any{format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "With", varargs...)
	ret0, _ := ret[0].(Result)
	return ret0
}

// With indicates an expected call of With.
func (mr *MockBreakableResultMockRecorder) With(format any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{format}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "With", reflect.TypeOf((*MockBreakableResult)(nil).With), varargs...)
}

// MockContinuableResult is a mock of ContinuableResult interface.
type MockContinuableResult struct {
	ctrl     *gomock.Controller
	recorder *MockContinuableResultMockRecorder
}

// MockContinuableResultMockRecorder is the mock recorder for MockContinuableResult.
type MockContinuableResultMockRecorder struct {
	mock *MockContinuableResult
}

// NewMockContinuableResult creates a new mock instance.
func NewMockContinuableResult(ctrl *gomock.Controller) *MockContinuableResult {
	mock := &MockContinuableResult{ctrl: ctrl}
	mock.recorder = &MockContinuableResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContinuableResult) EXPECT() *MockContinuableResultMockRecorder {
	return m.recorder
}

// Continue mocks base method.
func (m *MockContinuableResult) Continue() WithMessage {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Continue")
	ret0, _ := ret[0].(WithMessage)
	return ret0
}

// Continue indicates an expected call of Continue.
func (mr *MockContinuableResultMockRecorder) Continue() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Continue", reflect.TypeOf((*MockContinuableResult)(nil).Continue))
}

// With mocks base method.
func (m *MockContinuableResult) With(format string, args ...any) Result {
	m.ctrl.T.Helper()
	varargs := []any{format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "With", varargs...)
	ret0, _ := ret[0].(Result)
	return ret0
}

// With indicates an expected call of With.
func (mr *MockContinuableResultMockRecorder) With(format any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{format}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "With", reflect.TypeOf((*MockContinuableResult)(nil).With), varargs...)
}

// MockTaskRunner is a mock of TaskRunner interface.
type MockTaskRunner[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockTaskRunnerMockRecorder[T]
}

// MockTaskRunnerMockRecorder is the mock recorder for MockTaskRunner.
type MockTaskRunnerMockRecorder[T any] struct {
	mock *MockTaskRunner[T]
}

// NewMockTaskRunner creates a new mock instance.
func NewMockTaskRunner[T any](ctrl *gomock.Controller) *MockTaskRunner[T] {
	mock := &MockTaskRunner[T]{ctrl: ctrl}
	mock.recorder = &MockTaskRunnerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskRunner[T]) EXPECT() *MockTaskRunnerMockRecorder[T] {
	return m.recorder
}

// AddTasks mocks base method.
func (m *MockTaskRunner[T]) AddTasks(tasks ...Task[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range tasks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "AddTasks", varargs...)
}

// AddTasks indicates an expected call of AddTasks.
func (mr *MockTaskRunnerMockRecorder[T]) AddTasks(tasks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddTasks", reflect.TypeOf((*MockTaskRunner[T])(nil).AddTasks), tasks...)
}

// Run mocks base method.
func (m *MockTaskRunner[T]) Run(ctx Context[T]) (controller_runtime.Result, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", ctx)
	ret0, _ := ret[0].(controller_runtime.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Run indicates an expected call of Run.
func (mr *MockTaskRunnerMockRecorder[T]) Run(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockTaskRunner[T])(nil).Run), ctx)
}

// MockTask is a mock of Task interface.
type MockTask[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockTaskMockRecorder[T]
}

// MockTaskMockRecorder is the mock recorder for MockTask.
type MockTaskMockRecorder[T any] struct {
	mock *MockTask[T]
}

// NewMockTask creates a new mock instance.
func NewMockTask[T any](ctrl *gomock.Controller) *MockTask[T] {
	mock := &MockTask[T]{ctrl: ctrl}
	mock.recorder = &MockTaskMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTask[T]) EXPECT() *MockTaskMockRecorder[T] {
	return m.recorder
}

// Name mocks base method.
func (m *MockTask[T]) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockTaskMockRecorder[T]) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockTask[T])(nil).Name))
}

// Sync mocks base method.
func (m *MockTask[T]) Sync(ctx Context[T]) Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sync", ctx)
	ret0, _ := ret[0].(Result)
	return ret0
}

// Sync indicates an expected call of Sync.
func (mr *MockTaskMockRecorder[T]) Sync(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sync", reflect.TypeOf((*MockTask[T])(nil).Sync), ctx)
}

// MockTaskReporter is a mock of TaskReporter interface.
type MockTaskReporter struct {
	ctrl     *gomock.Controller
	recorder *MockTaskReporterMockRecorder
}

// MockTaskReporterMockRecorder is the mock recorder for MockTaskReporter.
type MockTaskReporterMockRecorder struct {
	mock *MockTaskReporter
}

// NewMockTaskReporter creates a new mock instance.
func NewMockTaskReporter(ctrl *gomock.Controller) *MockTaskReporter {
	mock := &MockTaskReporter{ctrl: ctrl}
	mock.recorder = &MockTaskReporterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskReporter) EXPECT() *MockTaskReporterMockRecorder {
	return m.recorder
}

// AddResult mocks base method.
func (m *MockTaskReporter) AddResult(name, status, msg string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddResult", name, status, msg)
}

// AddResult indicates an expected call of AddResult.
func (mr *MockTaskReporterMockRecorder) AddResult(name, status, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddResult", reflect.TypeOf((*MockTaskReporter)(nil).AddResult), name, status, msg)
}

// Summary mocks base method.
func (m *MockTaskReporter) Summary() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Summary")
	ret0, _ := ret[0].(string)
	return ret0
}

// Summary indicates an expected call of Summary.
func (mr *MockTaskReporterMockRecorder) Summary() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Summary", reflect.TypeOf((*MockTaskReporter)(nil).Summary))
}
